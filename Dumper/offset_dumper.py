#!/usr/bin/env python3
"""
offsetmgr.py

Simple offsets/config manager (pure Python, standard library only).

Features:
 - store offsets in JSON
 - add/update/remove offsets via CLI
 - export to C++ header or C# static class
 - serve offsets over HTTP as JSON
 - timestamped dumps

NOTE: This tool does NOT read or modify another process's memory.
      It's a helper for managing numeric offsets and metadata only.
"""

import argparse
import json
import os
import sys
import datetime
from http.server import HTTPServer, BaseHTTPRequestHandler
from threading import Thread
from urllib.parse import urlparse, parse_qs

DB_FILENAME = "offsets.json"


def load_db(path=DB_FILENAME):
    if os.path.exists(path):
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    else:
        return {"meta": {"generated_at": None, "version": "0.0"}, "offsets": {}}


def save_db(db, path=DB_FILENAME):
    db["meta"]["generated_at"] = datetime.datetime.utcnow().isoformat() + "Z"
    with open(path, "w", encoding="utf-8") as f:
        json.dump(db, f, indent=2, sort_keys=True)


def add_offset(db, name, value_hex, comment=""):
    try:
        value = int(value_hex, 16) if isinstance(value_hex, str) else int(value_hex)
    except Exception:
        raise ValueError("value must be hex string (0x...) or integer")
    db["offsets"][name] = {"value": value, "hex": "0x{0:08X}".format(value), "comment": comment}
    return db


def remove_offset(db, name):
    if name in db["offsets"]:
        del db["offsets"][name]
        return db
    raise KeyError(f"offset '{name}' not found")


def export_cpp_header(db, out_path, guard_name="OFFSETS_H"):
    lines = []
    lines.append(f"#ifndef {guard_name}")
    lines.append(f"#define {guard_name}")
    lines.append("")
    lines.append("// Generated by offsetmgr.py")
    lines.append(f"// Generated at: {db['meta'].get('generated_at')}")
    lines.append("")
    for k, v in db["offsets"].items():
        lines.append(f"static const unsigned int {k} = {v['hex']}; // {v.get('comment','')}")
    lines.append("")
    lines.append(f"#endif // {guard_name}")
    with open(out_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))
    return out_path


def export_csharp_class(db, out_path, namespace="Offsets", class_name="Offsets"):
    lines = []
    lines.append("// Generated by offsetmgr.py")
    lines.append(f"// Generated at: {db['meta'].get('generated_at')}")
    lines.append(f"namespace {namespace} {{")
    lines.append(f"    public static class {class_name} {{")
    for k, v in db["offsets"].items():
        lines.append(f"        public const uint {k} = {v['hex']}; // {v.get('comment','')}")
    lines.append("    }")
    lines.append("}")
    with open(out_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))
    return out_path


class OffsetsHTTPRequestHandler(BaseHTTPRequestHandler):
    db = None

    def _write_json(self, data, code=200):
        b = json.dumps(data, indent=2, sort_keys=True).encode("utf-8")
        self.send_response(code)
        self.send_header("Content-Type", "application/json; charset=utf-8")
        self.send_header("Content-Length", str(len(b)))
        self.end_headers()
        self.wfile.write(b)

    def do_GET(self):
        parsed = urlparse(self.path)
        if parsed.path in ("/", "/offsets.json"):
            self._write_json(self.db)
            return
        if parsed.path.startswith("/offset/"):
            key = parsed.path[len("/offset/"):]
            if key in self.db["offsets"]:
                self._write_json({key: self.db["offsets"][key]})
            else:
                self._write_json({"error": "not found"}, code=404)
            return
        self._write_json({"error": "unknown endpoint"}, code=404)


def run_server(db, host="0.0.0.0", port=8000, no_block=False):
    OffsetsHTTPRequestHandler.db = db
    server = HTTPServer((host, port), OffsetsHTTPRequestHandler)
    print(f"Serving offsets on http://{host}:{port}/offsets.json (Ctrl+C to stop)")
    if no_block:
        t = Thread(target=server.serve_forever, daemon=True)
        t.start()
        return server
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print("Shutting down server")
        server.shutdown()
        server.server_close()


def list_offsets(db):
    if not db["offsets"]:
        print("No offsets stored.")
        return
    for name, info in sorted(db["offsets"].items()):
        print(f"{name:30} {info['hex']:12} {info.get('comment','')}")


def dump_timestamped(db, prefix="offsets_dump"):
    ts = datetime.datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
    fname = f"{prefix}_{ts}.json"
    with open(fname, "w", encoding="utf-8") as f:
        json.dump(db, f, indent=2, sort_keys=True)
    return fname


def parse_args():
    p = argparse.ArgumentParser(description="Offset manager (pure Python).")
    sub = p.add_subparsers(dest="cmd", required=False)

    sub_list = sub.add_parser("list", help="List offsets")
    sub_add = sub.add_parser("add", help="Add / update offset")
    sub_add.add_argument("name")
    sub_add.add_argument("value", help="hex (0x...) or decimal")
    sub_add.add_argument("-c", "--comment", default="", help="comment")

    sub_rm = sub.add_parser("rm", help="Remove offset")
    sub_rm.add_argument("name")

    sub_export = sub.add_parser("export", help="Export offsets to file")
    sub_export.add_argument("format", choices=["json", "cpp", "csharp"], help="export format")
    sub_export.add_argument("out", help="output file")

    sub_serve = sub.add_parser("serve", help="Serve offsets via HTTP")
    sub_serve.add_argument("--host", default="0.0.0.0")
    sub_serve.add_argument("--port", type=int, default=8000)
    sub_serve.add_argument("--noblock", action="store_true", help="run server in background (non-block)")

    sub_dump = sub.add_parser("dump", help="Create timestamped dump")
    sub_dump.add_argument("--prefix", default="offsets_dump")

    sub_info = sub.add_parser("info", help="Show DB filename and metadata")

    return p.parse_args()


def main():
    args = parse_args()
    db = load_db()

    if args.cmd == "list" or args.cmd is None:
        list_offsets(db)
        return

    if args.cmd == "add":
        try:
            add_offset(db, args.name, args.value, args.comment)
            save_db(db)
            print(f"Added/updated offset {args.name} = {args.value}")
        except Exception as e:
            print("Error:", e)
        return

    if args.cmd == "rm":
        try:
            remove_offset(db, args.name)
            save_db(db)
            print(f"Removed offset {args.name}")
        except KeyError as e:
            print("Error:", e)
        return

    if args.cmd == "export":
        fmt = args.format
        out = args.out
        if fmt == "json":
            save_db(db, out)
            print("Exported JSON to", out)
            return
        if fmt == "cpp":
            export_cpp_header(db, out)
            print("Exported C++ header to", out)
            return
        if fmt == "csharp":
            export_csharp_class(db, out)
            print("Exported C# class to", out)
            return

    if args.cmd == "serve":
        run_server(db, host=args.host, port=args.port, no_block=args.noblock)
        print("Server stopped.")
        return

    if args.cmd == "dump":
        fname = dump_timestamped(db, prefix=args.prefix)
        print("Dumped to", fname)
        return

    if args.cmd == "info":
        print("DB path:", DB_FILENAME)
        print("Meta:", json.dumps(db.get("meta", {}), indent=2))
        print("Offsets:", len(db.get("offsets", {})))
        return


if __name__ == "__main__":
    main()
